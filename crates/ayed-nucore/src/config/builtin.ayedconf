# Features I think could be useful/necessary:
# - "Scripts" as sequence of commands.
#       Usable in place of commands in keybinds, hooks, etc.
#       Async "scripts"?
# - ...?

mixin basic-movement {
    keybinds {
        <up> move u
        <down> move d
        <left> move l
        <right> move r
        <s-up> move u anchored
        <s-down> move d anchored
        <s-left> move l anchored
        <c-left> move-regex --reversed \w+|[^\s\w]+
        <cs-left> move-regex --reversed --anchored \w+|[^\s\w]+
        <s-right> move r anchored
        <c-right> move-regex \w+|[^\s\w]+
        <cs-right> move-regex --anchored \w+|[^\s\w]+
    }
}

mixin basic-deletion {
    keybinds {
        <del> delete
        <backspace> delete-around -p
        <a-backspace> delete-around
    }
}

@override
panel modeline {
    use basic-movement
    use basic-deletion

    keybinds {
        <esc> focus-panel editor
        <ret> modeline-exec
        else insert-char
    }
}


########################
### Editing keybinds ###

hooks {
    started  state-set mode text/command
}

mode text/command {
    use basic-movement
    use basic-deletion

    keybinds {
        w move u
        W move u anchored
        s move d
        S move d anchored
        a move l
        A move l anchored
        <c-a> move-regex --reversed \w+|[^\s\w]+
        d move r
        D move r anchored
        <c-d> move-regex \w+|[^\s\w]+
    
        C dupe d
        <a-C> dupe u
        ; selection-shrink
        <a-;> selection-flip

        k delete

        : focus-panel modeline
        i state-set mode text/insert
    }
}

mode text/insert {
    use basic-movement
    use basic-deletion

    keybinds {
        <backtab> state-set mode text/command
        <esc> state-set mode text/command
        else insert-char
    }
}


###########################
### General convenience ###

hooks {
    buffer-modified look-keep-primary-cursor-in-view
    resized look-keep-primary-cursor-in-view
}


########################
### Syntax highlight ###

hooks {
    buffer-opened  generate-highlights
    buffer-modified  generate-highlights
}

syntax-style {
    keyword             #4488cf
    keyword-statement   #aa77cc
    builtin             $[ #62b0fb ; priority:11 ]
    operator            #ddccdd
    delimiter           $[ #ccaa11 ; priority:11 ]
    macro               $[ #3377cc ; priority:11 ]
    type                $[ #55b89b ; priority:12 ]
    literal             $[ #aaddcc ; priority:11 ]
    string              $[ #bb8866 ; priority:14 ]
    function            $[ #b8a4fc ; priority:13 ]
    namespace           #55b89b
    comment             $[ #55887a ; priority:15 ]
}

file .*\.rs {
    syntax {
        keyword \b(let|impl|pub|fn|mod|use|as|self|Self|mut|unsafe|move|struct|enum|type)\b
        keyword-statement \b(if|else|while|for|in|loop|continue|break|match)\b
        builtin \b(Some|None|Ok|Err)\b
        operator (==|=|!=|\+|\+=|\-|\-=|\*|\*=|/|/=|!|\|\||&&|\||&|::|:|;|,|\.\.|\.|\?)
        delimiter (->|=>|\{|\}|\[|\]|\(|\)|<|>)
        macro \b([a-zA-Z0-9_]+\!)
        type $[ \b([A-Z][a-zA-Z0-9_]*)\b ; \b((u|i)(8|16|32|64|128)|f32|f64)\b ; \b(char)\b ]
        literal $[ (([0-9]*\.[0-9]+|[0-9]+\.|[0-9]+)((u|i)(8|16|32|64|128)|f32|f64)?) ; \b(true|false)\b ]
        string $[ (r?\"[^\"]*\") ; (r?'[^']*') ]
        function \b([a-z0-9_][a-zA-Z0-9_]*)\(
        namespace \b([a-zA-Z0-9_]+)::
        comment (//.*)$
    }
}


########################
###  Line wrapping   ###

hooks {
    started state-set line-wrap none
}

line-wrap none {
    hooks {
        state-modified:line-wrap vbuf-clear
    }
}

line-wrap wrap {
    hooks {
        state-modified:line-wrap vbuf-line-wrap-rebuild
        buffer-opened vbuf-line-wrap-rebuild
        buffer-modified vbuf-line-wrap-rebuild
        resized vbuf-line-wrap-rebuild
    }
}
